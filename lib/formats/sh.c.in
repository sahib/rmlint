/*
 *  This file is part of rmlint.
 *
 *  rmlint is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  rmlint is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with rmlint.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *
 *  - Christopher <sahib> Pahl 2010-2014 (https://github.com/sahib)
 *  - Daniel <SeeSpotRun> T.   2014-2014 (https://github.com/SeeSpotRun)
 *
 * Hosted on http://github.com/sahib/rmlint
 *
 */

#include "../formats.h"
#include "../preprocess.h"

#include <glib.h>
#include <stdio.h>
#include <string.h>


typedef struct RmFmtHandlerShScript {
    RmFmtHandler parent;
    RmFile *last_original;
    RmSession *session;

    bool allow_user_cmd : 1;
    bool allow_reflink : 1;
    bool allow_symlink : 1;
    bool allow_hardlink : 1;
    bool allow_remove : 1;

    const char *user_cmd;

    GByteArray *order;
} RmFmtHandlerShScript;

static const char *SH_SCRIPT_TEMPLATE_HEAD = "<<SH_SOURCE>>";
static const char *SH_SCRIPT_TEMPLATE_FOOT =
    "                                               \n"
    "######### END OF AUTOGENERATED OUTPUT #########\n"
    "                                               \n"
    "if [ -z $DO_REMOVE ] && [ -z $DO_DRY_RUN ]     \n"
    "then                                           \n"
    "  echo \"Deleting script \" \"$0\"             \n" 
    "  %s '%s';                                     \n"
    "fi                                             \n"
    ;

typedef bool (* RmShOrderEmitFunc)(RmFmtHandlerShScript *self, char **out, RmFile *file, char *path, char *orig_path);


static bool rm_sh_emit_handler_user(RmFmtHandlerShScript *self, char **out, _U RmFile *file, char *path, char *orig_path) {
    if(self->user_cmd == NULL || !self->allow_user_cmd) {
        return false;
    }

    *out = g_strdup_printf("user_command '%s' '%s'", path, orig_path);
    return true;
}

static bool rm_sh_emit_handler_reflink(RmFmtHandlerShScript *self, char **out, RmFile *file, char *path, char *orig_path) {
    if(!self->allow_reflink || !rm_mounts_can_reflink(self->session->mounts, self->last_original->dev, file->dev)) {
        return false;
    }

    if ( rm_offsets_match(path, orig_path) ) {
        *out = g_strdup_printf("skip_reflink '%s' '%s'", path, orig_path);
    } else {
        *out = g_strdup_printf("cp_reflink '%s' '%s'", path, orig_path);
    }
    return true;
}

static bool rm_sh_emit_handler_symlink(RmFmtHandlerShScript *self, char **out, RmFile *file, char *path, char *orig_path) {
    if(!self->allow_symlink || self->last_original->dev != file->dev) {
        return false;
    }

    *out = g_strdup_printf("cp_symlink '%s' '%s'", path, orig_path);
    return true;
}

static bool rm_sh_emit_handler_hardlink(RmFmtHandlerShScript *self, char **out, _U RmFile *file, char *path, char *orig_path) {
    if(!self->allow_hardlink) {
        return false;
    }
    if (self->last_original && file->hardlinks.hardlink_head == self->last_original) {
        *out = g_strdup_printf("skip_hardlink '%s' '%s'", path, orig_path);
    } else {
        *out = g_strdup_printf("cp_hardlink '%s' '%s'", path, orig_path);
    }
    return true;
}

static bool rm_sh_emit_handler_remove(RmFmtHandlerShScript *self, char **out, _U RmFile *file, char *path, char *orig_path) {
    if(!self->allow_remove) {
        return false;
    }

    *out = g_strdup_printf("remove_cmd '%s' # == %s", path, orig_path);
    return true;
}

typedef enum RmShHandler {
    RM_SH_HANDLER_UNKNOWN = 0,
    RM_SH_HANDLER_USER_COMMAND,
    RM_SH_HANDLER_REFLINK,
    RM_SH_HANDLER_SYMLINK,
    RM_SH_HANDLER_HARDLINK,
    RM_SH_HANDLER_REMOVE,
    RM_SH_HANDLER_N
} RmShHandler;

static const char *ORDER_TO_STRING[] = {
    [RM_SH_HANDLER_UNKNOWN] = NULL,
    [RM_SH_HANDLER_USER_COMMAND] = "cmd",
    [RM_SH_HANDLER_REFLINK] = "reflink",
    [RM_SH_HANDLER_SYMLINK] = "symlink",
    [RM_SH_HANDLER_HARDLINK] = "hardlink",
    [RM_SH_HANDLER_REMOVE] = "remove",
    [RM_SH_HANDLER_N] = NULL
};

static const RmShOrderEmitFunc ORDER_TO_FUNC[] = {
    [RM_SH_HANDLER_UNKNOWN] = NULL,
    [RM_SH_HANDLER_USER_COMMAND] = rm_sh_emit_handler_user,
    [RM_SH_HANDLER_REFLINK] = rm_sh_emit_handler_reflink,
    [RM_SH_HANDLER_SYMLINK] = rm_sh_emit_handler_symlink,
    [RM_SH_HANDLER_HARDLINK] = rm_sh_emit_handler_hardlink,
    [RM_SH_HANDLER_REMOVE] = rm_sh_emit_handler_remove
};

static void rm_sh_parse_handlers(RmFmtHandlerShScript *self, const char *handler_cfg) {
    self->order = g_byte_array_new();

    char **order_vec = g_strsplit(handler_cfg, ",", -1);
    for(int i = 0; order_vec && order_vec[i]; ++i) {
        bool found = false;
        for(RmShHandler n = 0; n < RM_SH_HANDLER_N; ++n) {
            if(ORDER_TO_STRING[n] == NULL) {
                continue;
            }

            if(strcasecmp(order_vec[i], ORDER_TO_STRING[n]) == 0) {
                switch(n) {
                case RM_SH_HANDLER_USER_COMMAND:
                    self->allow_user_cmd = true;
                    break;
                case RM_SH_HANDLER_REFLINK:
                    self->allow_reflink = true;
                    break;
                case RM_SH_HANDLER_SYMLINK:
                    self->allow_symlink = true;
                    break;
                case RM_SH_HANDLER_HARDLINK:
                    self->allow_hardlink = true;
                    break;
                case RM_SH_HANDLER_REMOVE:
                    self->allow_remove = true;
                    break;
                default:
                    g_assert_not_reached();
                }

                /* we found the id */
                g_byte_array_append(self->order, (guint8 *)&n, 1);
                found = true;
                break;
            }
        }

        if(!found) {
            rm_log_error_line(_("%s is an invalid handler."), order_vec[i]);
        }
    }

    g_strfreev(order_vec);
}

static void rm_fmt_head(RmSession *session, RmFmtHandler *parent, FILE *out) {
    RmFmtHandlerShScript *self = (RmFmtHandlerShScript *)parent;
    char *script_header = NULL;

    self->session = session;
    self->user_cmd = rm_fmt_get_config_value(session->formats, "sh", "cmd");

    const char *handler_cfg = rm_fmt_get_config_value(session->formats, "sh", "handler");
    if(handler_cfg != NULL) {
        /* user specified handlers */
        rm_sh_parse_handlers(self, handler_cfg);
    } else if(rm_fmt_get_config_value(session->formats, "sh", "link") != NULL) {
        /* Preset: try reflinks, then symlinks then hardlinks */
        rm_sh_parse_handlers(self, "reflink,hardlink,symlink");
    } else if(rm_fmt_get_config_value(session->formats, "sh", "hardlink") != NULL) {
        /* Preset: try symlinks before using hardlinks */
        rm_sh_parse_handlers(self, "hardlink,symlink");
    } else if(rm_fmt_get_config_value(session->formats, "sh", "symlink") != NULL) {
        /* Preset: only do hardlinks */
        rm_sh_parse_handlers(self, "symlink");
    } else {
        /* Default: remove the file */
        rm_sh_parse_handlers(self, "cmd,remove");
    }

    if(fchmod(fileno(out), S_IRUSR | S_IWUSR | S_IXUSR) == -1) {
        rm_log_perror("Could not chmod +x sh script");
    }

    /* Fill in all placeholders in the script template */
    fprintf(
        out, SH_SCRIPT_TEMPLATE_HEAD,
        session->cfg->iwd,
        (session->cfg->joined_argv) ? (session->cfg->joined_argv) : "[unknown]",
        rm_util_get_username(),
        rm_util_get_groupname(),
        (self->user_cmd) ? self->user_cmd : "echo 'no user command defined.'",
        (session->cfg->joined_argv) ? (session->cfg->joined_argv) : "unknown_commandline"
    );

    g_free(script_header);
}

static char *rm_fmt_sh_escape_path(char *path) {
    /* See http://stackoverflow.com/questions/1250079/bash-escaping-single-quotes-inside-of-single-quoted-strings
     * for more info on this
     * */
    return rm_util_strsub(path, "'", "'\"'\"'");
}

static void rm_fmt_write_duplicate(RmFmtHandlerShScript *self, FILE *out, RmFile *file) {
    bool is_dir = (file->lint_type == RM_LINT_TYPE_DUPE_DIR_CANDIDATE);

    RM_DEFINE_PATH(file);

    char *path = rm_fmt_sh_escape_path(file_path);
    char *prefix = NULL;
    const char *comment = NULL;

    if(file->is_original) {
        if(is_dir) {
            comment = "# original directory";
        } else {
            comment = "# original";
        }

        prefix = g_strdup_printf("echo 'Keeping: ' '%s'", path);
        self->last_original = file;
    } else {
        g_assert(self->last_original);

        RmFile *last_original = self->last_original;
        RM_DEFINE_PATH(last_original);

        char *orig_path = rm_fmt_sh_escape_path(last_original_path);
        if(is_dir) {
            comment = "# duplicate directory";
        } else {
            comment = "# duplicate";
        }

        for(gsize n = 0; n < self->order->len; ++n) {
            RmShOrderEmitFunc func = ORDER_TO_FUNC[self->order->data[n]];
            if(func == NULL) {
                rm_log_error_line("null-func in sh formatter. Should not happen.");
                continue;
            }

            if(func(self, &prefix, file, path, orig_path) && prefix) {
                break;
            }
        }

        g_free(orig_path);
    }

    if(prefix != NULL) {
        fprintf(out, "%s %s\n", prefix, comment);
        g_free(prefix);
    }

    g_free(path);
}

static void rm_fmt_elem(_U RmSession *session, _U RmFmtHandler *parent, FILE *out, RmFile *file) {
    RmFmtHandlerShScript *self = (RmFmtHandlerShScript *)parent;
    if(file->lint_type == RM_LINT_TYPE_UNFINISHED_CKSUM) {
        return;
    }

    RM_DEFINE_PATH(file);
    char *path = rm_fmt_sh_escape_path(file_path);

    switch(file->lint_type) {
    case RM_LINT_TYPE_EMPTY_DIR:
        fprintf(out, "handle_emptydir '%s' # empty folder\n", path);
        break;
    case RM_LINT_TYPE_EMPTY_FILE:
        fprintf(out, "handle_emptyfile '%s' # empty file\n", path);
        break;
    case RM_LINT_TYPE_BADLINK:
        fprintf(out, "handle_bad_symlink '%s' # bad symlink pointing nowhere\n", path);
        break;
    case RM_LINT_TYPE_NONSTRIPPED:
        fprintf(out, "handle_unstripped_binary '%s' # binary with debugsymbols\n", path);
        break;
    case RM_LINT_TYPE_BADUID:
        fprintf(out, "handle_bad_user_id '%s' # bad uid\n", path);
        break;
    case RM_LINT_TYPE_BADGID:
        fprintf(out, "handle_bad_group_id '%s' # bad gid\n", path);
        break;
    case RM_LINT_TYPE_BADUGID:
        fprintf(out, "handle_bad_user_and_group_id '%s' # bad gid\n", path);
        break;
    case RM_LINT_TYPE_DUPE_DIR_CANDIDATE:
    case RM_LINT_TYPE_DUPE_CANDIDATE:
        rm_fmt_write_duplicate(self, out, file);
        break;
    default:
        rm_log_warning("Warning: unknown type in encountered: %d\n", file->lint_type);
        break;
    }

    g_free(path);
}

static void rm_fmt_foot(_U RmSession *session, RmFmtHandler *parent, FILE *out) {
    RmFmtHandlerShScript *self = (RmFmtHandlerShScript *)parent;
    g_byte_array_free(self->order, true);

    if(rm_fmt_is_stream(session->formats, parent)) {
        /* You will have a hard time deleting standard streams. */
        return;
    }

    fprintf(out, SH_SCRIPT_TEMPLATE_FOOT, "rm -f", parent->path);
}

static RmFmtHandlerShScript SH_SCRIPT_HANDLER_IMPL = {
    .parent = {
        .size = sizeof(SH_SCRIPT_HANDLER_IMPL),
        .name = "sh",
        .head = rm_fmt_head,
        .elem = rm_fmt_elem,
        .prog = NULL,
        .foot = rm_fmt_foot,
        .valid_keys = {"handler", "cmd", "link", "hardlink", "symlink", NULL},
    },
    .last_original = NULL
};

RmFmtHandler *SH_SCRIPT_HANDLER = (RmFmtHandler *) &SH_SCRIPT_HANDLER_IMPL;
