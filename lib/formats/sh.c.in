/*
 *  This file is part of rmlint.
 *
 *  rmlint is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  rmlint is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with rmlint.  If not, see <http://www.gnu.org/licenses/>.
 *
 * Authors:
 *
 *  - Christopher <sahib> Pahl 2010-2021 (https://github.com/sahib)
 *  - Daniel <SeeSpotRun> T.   2014-2021 (https://github.com/SeeSpotRun)
 *
 * Hosted on http://github.com/sahib/rmlint
 *
 */

#include "../formats.h"
#include <string.h>


typedef struct RmFmtHandlerShScript {
    RmFmtHandler parent;
    RmFile *last_original;
    RmSession *session;

    bool allow_user_cmd : 1;
    bool allow_clone : 1;
    bool allow_reflink : 1;
    bool allow_symlink : 1;
    bool allow_hardlink : 1;
    bool allow_remove : 1;

    const char *user_cmd;

    GByteArray *order;
    RmOff line_count;
} RmFmtHandlerShScript;

static const char *SH_SCRIPT_TEMPLATE_HEAD = "<<SH_SOURCE>>";
static const char *SH_SCRIPT_TEMPLATE_FOOT =
    "\n"
    "\n"
    "\n"
    "######### END OF AUTOGENERATED OUTPUT #########\n"
    "\n"
    "if [ \"$PROGRESS_CURR\" -le \"$PROGRESS_TOTAL\" ]; then\n"
    "    print_progress_prefix\n"
    "    printf \"${COL_BLUE}Done!${COL_RESET}\\n\"\n"
    "fi\n"
    "\n"
    "if [ -z \"$DO_REMOVE\" ] && [ -z \"$DO_DRY_RUN\" ]\n"
    "then\n"
    "  printf \"Deleting script %%s\\n\" \"$0\"\n"
    "  %s -- '%s';\n"
    "fi\n"
    ;

typedef bool (* RmShOrderEmitFunc)(RmFmtHandlerShScript *self, char **out, RmFile *file, char *dupe_path, char *orig_path, char *dupe_escaped, char *orig_escaped);


static bool rm_sh_emit_handler_user(RmFmtHandlerShScript *self, char **out, _UNUSED RmFile *file, _UNUSED char *dupe_path, _UNUSED char *orig_path, char *dupe_escaped, char *orig_escaped) {
    if(self->user_cmd == NULL || !self->allow_user_cmd) {
        return false;
    }

    *out = g_strdup_printf("user_command  '%s' '%s'", dupe_escaped, orig_escaped);
    return true;
}

static bool rm_sh_emit_handler_clone(RmFmtHandlerShScript *self, char **out, RmFile *file, char *dupe_path, char *orig_path, char *dupe_escaped, char *orig_escaped) {
    if(!self->allow_clone || self->session->mounts == NULL) {
        return false;
    }

    if (!rm_mounts_can_reflink(self->session->mounts, file->dev, self->last_original->dev) ) {
        return false;
    }

    /* Needs to have at least kernel 4.2 */
    if(!rm_session_check_kernel_version(4, 2)) {
        return false;
    }

    int link_type = rm_util_link_type(dupe_path, orig_path, TRUE);
    switch(link_type) {
    case RM_LINK_REFLINK:
    case RM_LINK_INLINE_EXTENTS:
        *out = g_strdup_printf("skip_reflink  '%s' '%s'", dupe_escaped, orig_escaped);
        return TRUE;
    case RM_LINK_SAME_FILE:
    case RM_LINK_NOT_FILE:
    case RM_LINK_WRONG_SIZE:
    case RM_LINK_PATH_DOUBLE:
    case RM_LINK_ERROR:
    case RM_LINK_XDEV:
    case RM_LINK_SYMLINK:
        rm_log_warning_line("Unexpected return code %d from rm_util_link_type()", link_type);
        return FALSE;
    case RM_LINK_HARDLINK:
    case RM_LINK_NONE:
        *out = g_strdup_printf("clone         '%s' '%s'", dupe_escaped, orig_escaped);
        return TRUE;
    default:
        g_assert_not_reached();
        return FALSE;
    }
}

static bool rm_sh_emit_handler_reflink(RmFmtHandlerShScript *self, char **out, RmFile *file, char *dupe_path, char *orig_path, char *dupe_escaped, char *orig_escaped) {
    if(!self->allow_reflink || self->session->mounts == NULL) {
        return false;
    }

    if(!rm_mounts_can_reflink(self->session->mounts, self->last_original->dev, file->dev)) {
        return false;
    }

    int link_type = rm_util_link_type(dupe_path, orig_path, TRUE);
    switch(link_type) {
    case RM_LINK_REFLINK:
        *out = g_strdup_printf("skip_reflink  '%s' '%s'", dupe_escaped, orig_escaped);
        return TRUE;
    case RM_LINK_SAME_FILE:
    case RM_LINK_NOT_FILE:
    case RM_LINK_WRONG_SIZE:
    case RM_LINK_PATH_DOUBLE:
    case RM_LINK_XDEV:
    case RM_LINK_ERROR:
        rm_log_warning_line("Unexpected return code %d from rm_util_link_type()", link_type);
        return FALSE;
    case RM_LINK_HARDLINK:
    case RM_LINK_SYMLINK:
    case RM_LINK_INLINE_EXTENTS:
    case RM_LINK_NONE:
        *out = g_strdup_printf("cp_reflink    '%s' '%s'", dupe_escaped, orig_escaped);
        return TRUE;
    default:
        g_assert_not_reached();
        return FALSE;
    }
}

static bool rm_sh_emit_handler_symlink(RmFmtHandlerShScript *self, char **out, _UNUSED RmFile *file, _UNUSED char *dupe_path, _UNUSED char *orig_path, char *dupe_escaped, char *orig_escaped) {
    if(!self->allow_symlink) {
        return false;
    }

    *out = g_strdup_printf("cp_symlink    '%s' '%s'", dupe_escaped, orig_escaped);
    return true;
}

static bool rm_sh_emit_handler_hardlink(RmFmtHandlerShScript *self, char **out, _UNUSED RmFile *file, _UNUSED char *dupe_path, _UNUSED char *orig_path, char *dupe_escaped, char *orig_escaped) {
    if(!self->allow_hardlink || self->last_original->dev != file->dev) {
        return false;
    }

    if (self->last_original && RM_FILE_HARDLINK_HEAD(file) == self->last_original) {
        *out = g_strdup_printf("skip_hardlink '%s' '%s'", dupe_escaped, orig_escaped);
    } else {
        *out = g_strdup_printf("cp_hardlink   '%s' '%s'", dupe_escaped, orig_escaped);
    }
    return true;
}

static bool rm_sh_emit_handler_remove(RmFmtHandlerShScript *self, char **out, _UNUSED RmFile *file, _UNUSED char *dupe_path, _UNUSED char *orig_path, char *dupe_escaped, char *orig_escaped) {
    if(!self->allow_remove) {
        return false;
    }

    *out = g_strdup_printf("remove_cmd    '%s' '%s'", dupe_escaped, orig_escaped);
    return true;
}

typedef enum RmShHandler {
    RM_SH_HANDLER_UNKNOWN = 0,
    RM_SH_HANDLER_USER_COMMAND,
    RM_SH_HANDLER_CLONE,
    RM_SH_HANDLER_REFLINK,
    RM_SH_HANDLER_SYMLINK,
    RM_SH_HANDLER_HARDLINK,
    RM_SH_HANDLER_REMOVE,
    RM_SH_HANDLER_N
} RmShHandler;

static const char *ORDER_TO_STRING[] = {
    [RM_SH_HANDLER_UNKNOWN] = NULL,
    [RM_SH_HANDLER_USER_COMMAND] = "cmd",
    [RM_SH_HANDLER_CLONE] = "clone",
    [RM_SH_HANDLER_REFLINK] = "reflink",
    [RM_SH_HANDLER_SYMLINK] = "symlink",
    [RM_SH_HANDLER_HARDLINK] = "hardlink",
    [RM_SH_HANDLER_REMOVE] = "remove",
    [RM_SH_HANDLER_N] = NULL
};

static const RmShOrderEmitFunc ORDER_TO_FUNC[] = {
    [RM_SH_HANDLER_UNKNOWN] = NULL,
    [RM_SH_HANDLER_USER_COMMAND] = rm_sh_emit_handler_user,
    [RM_SH_HANDLER_CLONE] = rm_sh_emit_handler_clone,
    [RM_SH_HANDLER_REFLINK] = rm_sh_emit_handler_reflink,
    [RM_SH_HANDLER_SYMLINK] = rm_sh_emit_handler_symlink,
    [RM_SH_HANDLER_HARDLINK] = rm_sh_emit_handler_hardlink,
    [RM_SH_HANDLER_REMOVE] = rm_sh_emit_handler_remove
};

static void rm_sh_warn_if_reflink_not_compiled_in(void) {
#if !HAVE_BLKID || !HAVE_GIO_UNIX
    g_printerr("\n%sWARNING:%s reflink will not be emitted: please compile with blkid and gio-unix-2.0.\n", YELLOW, RESET);
#endif
}

static void rm_sh_parse_handlers(RmFmtHandlerShScript *self, const char *handler_cfg) {
    static GOnce log_once = G_ONCE_INIT;
    self->order = g_byte_array_new();

    char **order_vec = g_strsplit(handler_cfg, ",", -1);
    for(int i = 0; order_vec && order_vec[i]; ++i) {
        bool found = false;
        for(RmShHandler n = 0; n < RM_SH_HANDLER_N; ++n) {
            if(ORDER_TO_STRING[n] == NULL) {
                continue;
            }

            if(strcasecmp(order_vec[i], ORDER_TO_STRING[n]) == 0) {
                switch(n) {
                case RM_SH_HANDLER_USER_COMMAND:
                    self->allow_user_cmd = true;
                    break;
                case RM_SH_HANDLER_CLONE:
                    self->allow_clone = true;
                    g_once(&log_once, (GThreadFunc)rm_sh_warn_if_reflink_not_compiled_in, NULL);
                    break;
                case RM_SH_HANDLER_REFLINK:
                    self->allow_reflink = true;
                    g_once(&log_once, (GThreadFunc)rm_sh_warn_if_reflink_not_compiled_in, NULL);
                    break;
                case RM_SH_HANDLER_SYMLINK:
                    self->allow_symlink = true;
                    break;
                case RM_SH_HANDLER_HARDLINK:
                    self->allow_hardlink = true;
                    break;
                case RM_SH_HANDLER_REMOVE:
                    self->allow_remove = true;
                    break;
                default:
                    g_assert_not_reached();
                }

                /* we found the id */
                g_byte_array_append(self->order, (guint8 *)&n, 1);
                found = true;
                break;
            }
        }

        if(!found) {
            rm_log_error_line(_("%s is an invalid handler."), order_vec[i]);
        }
    }

    g_strfreev(order_vec);
}

static char *rm_fmt_sh_get_extra_equal_args(RmSession *session) {
    RmCfg *cfg = session->cfg;
    GString *buf = g_string_new(NULL);

    if(cfg->see_symlinks == false) {
        if(cfg->follow_symlinks) {
            g_string_append(buf, " --followlinks");
        } else {
            g_string_append(buf, " --no-followlinks");
        }
    }

    if(cfg->find_hardlinked_dupes == false) {
        g_string_append(buf, " --no-hardlinked");
    }

    if(cfg->honour_dir_layout == true) {
        g_string_append(buf, " --honour-dir-layout");
    }

    return g_string_free(buf, false);
}

static char *rm_fmt_sh_get_extra_dedupe_args(RmSession *session) {
    RmCfg *cfg = session->cfg;

    if(cfg->write_cksum_to_xattr) {
        return " --xattr";
    }

    return "";
}

static void rm_fmt_head(RmSession *session, RmFmtHandler *parent, FILE *out) {
    RmFmtHandlerShScript *self = (RmFmtHandlerShScript *)parent;

    self->line_count = 0;
    self->session = session;
    self->user_cmd = rm_fmt_get_config_value(session->formats, "sh", "cmd");

    const char *handler_cfg = rm_fmt_get_config_value(session->formats, "sh", "handler");
    if(handler_cfg != NULL) {
        /* user specified handlers */
        rm_sh_parse_handlers(self, handler_cfg);
    } else if(rm_fmt_get_config_value(session->formats, "sh", "clone") != NULL) {
        /* Preset: try clone, then reflinks, then hardlinks then symlinks */
        rm_sh_parse_handlers(self, "clone,reflink,hardlink,symlink");
    } else if(rm_fmt_get_config_value(session->formats, "sh", "link") != NULL) {
        /* Preset: try reflinks, then then hardlinks then symlinks */
        rm_sh_parse_handlers(self, "reflink,hardlink,symlink");
    } else if(rm_fmt_get_config_value(session->formats, "sh", "reflink") != NULL) {
        /* Preset: same as above, just an alias */
        rm_sh_parse_handlers(self, "reflink,hardlink,symlink");
    } else if(rm_fmt_get_config_value(session->formats, "sh", "hardlink") != NULL) {
        /* Preset: try hardlinks before using symlinks */
        rm_sh_parse_handlers(self, "hardlink,symlink");
    } else if(rm_fmt_get_config_value(session->formats, "sh", "symlink") != NULL) {
        /* Preset: only do symlinks */
        rm_sh_parse_handlers(self, "symlink");
    } else {
        /* Default: remove the file */
        rm_sh_parse_handlers(self, "cmd,remove");
    }

    if(fchmod(fileno(out), S_IRUSR | S_IWUSR | S_IXUSR) == -1) {
        rm_log_perror("Could not chmod +x sh script");
    }

    char *equal_extra_args = rm_fmt_sh_get_extra_equal_args(session);
    char *dedupe_extra_args = rm_fmt_sh_get_extra_dedupe_args(session);

    /* Fill in all placeholders in the script template */
    /* This is a brittle hack of which the author should be ashamed. */
    fprintf(
        out, SH_SCRIPT_TEMPLATE_HEAD,
        session->cfg->iwd,
        (session->cfg->joined_argv) ? (session->cfg->joined_argv) : "[unknown]",
        (session->cfg->full_argv0_path) ? (session->cfg->full_argv0_path) : "$(which rmlint)",
        rm_util_get_username(),
        rm_util_get_groupname(),
        "'%b[%3d%%]%b '", /* The progress format */
        equal_extra_args,
        dedupe_extra_args,
        dedupe_extra_args,
        (self->user_cmd) ? self->user_cmd : "echo 'no user command defined.'",
        (session->cfg->joined_argv) ? (session->cfg->joined_argv) : "unknown_commandline"
    );

    g_free(equal_extra_args);
}

static char *rm_fmt_sh_escape_path(char *path) {
    /* See http://stackoverflow.com/questions/1250079/bash-escaping-single-quotes-inside-of-single-quoted-strings
     * for more info on this
     * */
    return rm_util_strsub(path, "'", "'\"'\"'");
}

static void rm_fmt_write_duplicate(RmFmtHandlerShScript *self, FILE *out, RmFile *file) {
    bool is_dir = (file->lint_type == RM_LINT_TYPE_DUPE_DIR);

    RM_DEFINE_PATH(file);

    char *file_escaped = rm_fmt_sh_escape_path(file_path);
    char *prefix = NULL;
    const char *comment = NULL;

    if(file->is_original) {
        if(is_dir) {
            comment = "# original directory";
        } else {
            comment = "# original";
        }

        prefix = g_strdup_printf("\noriginal_cmd  '%s'", file_escaped);
        self->last_original = file;
    } else if(self->last_original) {

        RmFile *last_original = self->last_original;
        RM_DEFINE_PATH(last_original);

        char *orig_escaped = rm_fmt_sh_escape_path(last_original_path);
        if(is_dir) {
            comment = "# duplicate directory";
        } else {
            comment = "# duplicate";
        }

        for(gsize n = 0; n < self->order->len; ++n) {
            RmShOrderEmitFunc func = ORDER_TO_FUNC[self->order->data[n]];
            if(func == NULL) {
                rm_log_error_line("null-func in sh formatter. Should not happen.");
                continue;
            }

            if(func(self, &prefix, file, file_path, last_original_path, file_escaped, orig_escaped) && prefix) {
                break;
            }
        }

        g_free(orig_escaped);
    }

    if(prefix != NULL) {
        fprintf(out, "%s %s\n", prefix, comment);
        g_free(prefix);
    }

    g_free(file_escaped);
}

static void rm_fmt_elem(_UNUSED RmSession *session, _UNUSED RmFmtHandler *parent, FILE *out, RmFile *file) {
    RmFmtHandlerShScript *self = (RmFmtHandlerShScript *)parent;

    RM_DEFINE_PATH(file);
    char *path = rm_fmt_sh_escape_path(file_path);

    bool count_as_line = true;

    switch(file->lint_type) {
    case RM_LINT_TYPE_EMPTY_DIR:
        fprintf(out, "handle_emptydir '%s' # empty folder\n", path);
        break;
    case RM_LINT_TYPE_EMPTY_FILE:
        fprintf(out, "handle_emptyfile '%s' # empty file\n", path);
        break;
    case RM_LINT_TYPE_BADLINK:
        fprintf(out, "handle_bad_symlink '%s' # bad symlink pointing nowhere\n", path);
        break;
    case RM_LINT_TYPE_NONSTRIPPED:
        fprintf(out, "handle_unstripped_binary '%s' # binary with debugsymbols\n", path);
        break;
    case RM_LINT_TYPE_BADUID:
        fprintf(out, "handle_bad_user_id '%s' # bad uid\n", path);
        break;
    case RM_LINT_TYPE_BADGID:
        fprintf(out, "handle_bad_group_id '%s' # bad gid\n", path);
        break;
    case RM_LINT_TYPE_BADUGID:
        fprintf(out, "handle_bad_user_and_group_id '%s' # bad gid\n", path);
        break;
    case RM_LINT_TYPE_DUPE_DIR:
    case RM_LINT_TYPE_DUPE:
        rm_fmt_write_duplicate(self, out, file);
        break;
    case RM_LINT_TYPE_DUPE_CANDIDATE:
        g_assert_not_reached();
        break;
    case RM_LINT_TYPE_UNIQUE_FILE:
    case RM_LINT_TYPE_PART_OF_DIRECTORY:
    case RM_LINT_TYPE_DUPE_DIR_CANDIDATE:
        count_as_line = false;
        break;
    default:
        count_as_line = false;
        rm_log_warning("warning: sh: unknown type in encountered: %d\n", file->lint_type);
        break;
    }

    if(count_as_line) {
        self->line_count++;
    }

    g_free(path);
}

static void rm_fmt_foot(_UNUSED RmSession *session, RmFmtHandler *parent, FILE *out) {
    RmFmtHandlerShScript *self = (RmFmtHandlerShScript *)parent;
    g_byte_array_free(self->order, true);

    if(rm_fmt_is_stream(session->formats, parent)) {
        /* You will have a hard time deleting standard streams. */
        return;
    }

    char *escaped_path = rm_fmt_sh_escape_path(parent->path);
    fprintf(out, SH_SCRIPT_TEMPLATE_FOOT, "rm -f", escaped_path);

    const char progress_marker_text[] = "PROGRESS_TOTAL=";
    char *progress_marker = strstr(SH_SCRIPT_TEMPLATE_HEAD, progress_marker_text);
    if(progress_marker != NULL) {
        gsize offset = (progress_marker - SH_SCRIPT_TEMPLATE_HEAD) +
                       sizeof(progress_marker_text) - 1;

        /* Go to the exact write position */
        if(fseek(out, offset, SEEK_SET) != -1) {
            if(fprintf(out, "%"LLU, self->line_count) < 0) {
                rm_log_perror("writing total progress failed; there will be no proress bar");
            }
        } else {
            rm_log_perror("Seeking in script failed; there will be no progress bar");
        }
    }

    g_free(escaped_path);
}

static RmFmtHandlerShScript SH_SCRIPT_HANDLER_IMPL = {
    .parent = {
        .size = sizeof(SH_SCRIPT_HANDLER_IMPL),
        .name = "sh",
        .head = rm_fmt_head,
        .elem = rm_fmt_elem,
        .prog = NULL,
        .foot = rm_fmt_foot,
        .valid_keys = {"handler", "cmd", "clone", "link", "hardlink", "symlink", "reflink", NULL},
    },
    .last_original = NULL,
    .line_count = 0
};

RmFmtHandler *SH_SCRIPT_HANDLER = (RmFmtHandler *) &SH_SCRIPT_HANDLER_IMPL;
